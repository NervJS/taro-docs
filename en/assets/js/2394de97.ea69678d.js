"use strict";(self.webpackChunktaro_docs=self.webpackChunktaro_docs||[]).push([[21256],{58860:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>y});var o=n(37953);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=o.createContext({}),c=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(i.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=a,y=u["".concat(i,".").concat(m)]||u[m]||d[m]||r;return n?o.createElement(y,s(s({ref:t},p),{},{components:n})):o.createElement(y,s({ref:t},p))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=m;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[u]="string"==typeof e?e:a,s[1]=l;for(var c=2;c<r;c++)s[c]=n[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},84098:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>y,frontMatter:()=>l,metadata:()=>c,toc:()=>u});n(37953);var o=n(58860);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}const l={title:"Lifecycle & State"},i=void 0,c={unversionedId:"state",id:"version-3.x/state",title:"Lifecycle & State",description:"In this section, we will learn how to reuse and encapsulate a Clock component. It will set the timer, and updated once per second.",source:"@site/i18n/en/docusaurus-plugin-content-docs/version-3.x/state.md",sourceDirName:".",slug:"/state",permalink:"/taro-docs/en/docs/3.x/state",draft:!1,editUrl:"https://github.com/nervjs/taro-docs/edit/master/versioned_docs/version-3.x/state.md",tags:[],version:"3.x",frontMatter:{title:"Lifecycle & State"}},p={},u=[{value:"For a class to add local state",id:"for-a-class-to-add-local-state",level:2},{value:"The method of life cycle are added to the class",id:"the-method-of-life-cycle-are-added-to-the-class",level:2},{value:"Proper use of the State",id:"proper-use-of-the-state",level:2},{value:"Do not directly update the status",id:"do-not-directly-update-the-status",level:3},{value:"Status updates must be asynchronous",id:"status-updates-must-be-asynchronous",level:3},{value:"state update will be merged",id:"state-update-will-be-merged",level:3}],d={toc:u},m="wrapper";function y(e){var{components:t}=e,n=s(e,["components"]);return(0,o.yg)(m,r(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},o=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),o.forEach((function(t){a(e,t,n[t])}))}return e}({},d,n),{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"In this section, we will learn how to reuse and encapsulate a Clock component. It will set the timer, and updated once per second."),(0,o.yg)("p",null,"We can start over encapsulating the clock:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"class Clock extends Component {\n  render () {\n    return (\n      <View>\n        <Text>Hello, world!</Text>\n        <Text>And the time is {this.state.date.toLocaleTimeString()}.</Text>\n      </View>\n    )\n  }\n}\n")),(0,o.yg)("p",null,"Clock is defined as a class, now use will allow us to use other features, the local and life cycle such as hook."),(0,o.yg)("h2",{id:"for-a-class-to-add-local-state"},"For a class to add local state"),(0,o.yg)("p",null,"First, we need to add a class constructors to initialize the state ",(0,o.yg)("inlineCode",{parentName:"p"},"this.state"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"class Clock extends Component {\n  constructor (props) {\n    super(props)\n    this.state = { date: new Date() }\n  }\n\n  render () {\n    return (\n      <View>\n        <Text>Hello, world!</Text>\n        <Text>And the time is {this.state.date.toLocaleTimeString()}.</Text>\n      </View>\n    )\n  }\n}\n")),(0,o.yg)("p",null,"Notice how we deliver props to the base constructor:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"constructor (props) {\n  super(props)\n  this.state = { date: new Date() }\n}\n")),(0,o.yg)("p",null,"Class constructor component should always use props call basis.\nNext, we will make the Clock to set their own timer and updated once per second."),(0,o.yg)("h2",{id:"the-method-of-life-cycle-are-added-to-the-class"},"The method of life cycle are added to the class"),(0,o.yg)("p",null,"In application, with many components in the destruction of release resources component occupies very important."),(0,o.yg)("p",null,"Whenever ",(0,o.yg)("inlineCode",{parentName:"p"},"Clock")," components loaded into the DOM in first time, we all want to generate timer, it is called mount in Taro/React."),(0,o.yg)("p",null,"Also, when there is a Clock generated by the DOM has been removed, we will also want to clear the timer, this is known as unloading in Taro/React."),(0,o.yg)("p",null,"We can be declared in the component class special method, when the component mounted or uninstall, to run some code:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"class Clock extends Component {\n  constructor (props) {\n    super(props)\n    this.state = { date: new Date() }\n  }\n\n  componentDidMount() {\n\n  }\n\n  componentWillUnmount() {\n\n  }\n\n  render () {\n    return (\n      <View>\n        <Text>Hello, world!</Text>\n        <Text>And the time is {this.state.date.toLocaleTimeString()}.</Text>\n      </View>\n    )\n  }\n}\n")),(0,o.yg)("p",null,"These methods is called the life cycle of hooks."),(0,o.yg)("p",null,"When the component output to the DOM after executes ",(0,o.yg)("inlineCode",{parentName:"p"},"componentDidMount()")," hooks, it is a good place to set up the timer:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"componentDidMount() {\n  this.timerID = setInterval(\n    () => this.tick(),\n    1000\n  )\n}\n")),(0,o.yg)("p",null,"Notice how we save the timer in this ID."),(0,o.yg)("p",null,"Although ",(0,o.yg)("inlineCode",{parentName:"p"},"this.props")," set by Taro itself and ",(0,o.yg)("inlineCode",{parentName:"p"},"this.state")," has special meaning, but if you need to store is not used for visual output, you can add other fields hand movements in the class."),(0,o.yg)("p",null,"If you're not ",(0,o.yg)("inlineCode",{parentName:"p"},"render()")," used in something, it should not be in the state."),(0,o.yg)("p",null,"We will be in ",(0,o.yg)("inlineCode",{parentName:"p"},"componentWillUnmount()")," uninstall timer in () hook life cycle:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"componentWillUnmount () {\n  clearInterval(this.timerID)\n}\n")),(0,o.yg)("p",null,"Finally, we implement the execute every second ",(0,o.yg)("inlineCode",{parentName:"p"},"tick()")," method."),(0,o.yg)("p",null,"It will use ",(0,o.yg)("inlineCode",{parentName:"p"},"this.setState()")," to update the local state:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"import Taro, { Component } from '@tarojs/taro'\n\nclass Clock extends Component {\n  constructor (props) {\n    super(props)\n    this.state = { date: new Date() }\n  }\n\n  componentDidMount () {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\n\n  componentWillUnmount () {\n    clearInterval(this.timerID)\n  }\n\n  tick () {\n    this.setState({\n      date: new Date()\n    });\n  }\n\n  render() {\n    return (\n      <View>\n        <Text>Hello, world!</Text>\n        <Text>And the time is {this.state.date.toLocaleTimeString()}.</Text>\n      </View>\n    )\n  }\n}\n")),(0,o.yg)("h2",{id:"proper-use-of-the-state"},"Proper use of the State"),(0,o.yg)("p",null,"About the setState () there are three things need to know:"),(0,o.yg)("h3",{id:"do-not-directly-update-the-status"},"Do not directly update the status"),(0,o.yg)("p",null,"For example, this code not to render the component:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"// Wrong\nthis.state.comment = 'Hello'\n")),(0,o.yg)("p",null,"Should be used ",(0,o.yg)("inlineCode",{parentName:"p"},"setState()"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"// Correct\nthis.setState({ comment: 'Hello' })\n")),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"setState()"),"  function is the only can update ",(0,o.yg)("inlineCode",{parentName:"p"},"this.state")," place."),(0,o.yg)("h3",{id:"status-updates-must-be-asynchronous"},"Status updates must be asynchronous"),(0,o.yg)("p",null,"Taro can be multiple ",(0,o.yg)("inlineCode",{parentName:"p"},"setState()")," call merged into a single call to improve performance."),(0,o.yg)("p",null,"Because ",(0,o.yg)("inlineCode",{parentName:"p"},"this.state")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"props")," must be asynchronous update, so you can't in ",(0,o.yg)("inlineCode",{parentName:"p"},"setState")," immediately get ",(0,o.yg)("inlineCode",{parentName:"p"},"state")," values, such as:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"// Suppose we set this.state.counter = 0\nupdateCounter () {\n  this.setState({\n    counter: 1\n  })\n  console.log(this.state.counter) // This counter is 0\n}\n")),(0,o.yg)("p",null,"Is the right thing in this way, the ",(0,o.yg)("inlineCode",{parentName:"p"},"setState")," second parameter pass in a callback:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"// Suppose we set this.state.counter = 0\nupdateCounter () {\n  this.setState({\n    counter: 1\n  }, () => {\n    // In this function you can get after setState values\n  })\n}\n")),(0,o.yg)("blockquote",null,(0,o.yg)("p",{parentName:"blockquote"},"This is the Taro and React a different places: Doesn't always React the ",(0,o.yg)("inlineCode",{parentName:"p"},"setState")," asynchronous, a set of transaction mechanism, his inner control, and React the implementation of the 15/16 also each are not identical. For Taro, ",(0,o.yg)("inlineCode",{parentName:"p"},"setState")," after you provide will be joining an array, and then the execution of the next one ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/aooy/blog/issues/5"},"eventloop")," merge them.")),(0,o.yg)("h3",{id:"state-update-will-be-merged"},"state update will be merged"),(0,o.yg)("p",null,"When you call ",(0,o.yg)("inlineCode",{parentName:"p"},"setState()"),", Taro will combine the current state of the object to you provide."),(0,o.yg)("p",null,"For example, your state may contain several independent variables:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"constructor(props) {\n  super(props)\n  this.state = {\n    posts: [],\n    comments: []\n  }\n}\n")),(0,o.yg)("p",null,"And then through a call to independence ",(0,o.yg)("inlineCode",{parentName:"p"},"setState()")," call to update them respectively:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"componentDidMount() {\n  fetchPosts().then(response => {\n    this.setState({\n      posts: response.posts\n    });\n  });\n\n  fetchComments().then(response => {\n    this.setState({\n      comments: response.comments\n    })\n  })\n}\n")),(0,o.yg)("p",null,"The merger is shallow, so ",(0,o.yg)("inlineCode",{parentName:"p"},"this.setState({comments})")," will not change ",(0,o.yg)("inlineCode",{parentName:"p"},"this.state.posts")," value, but will completely replace ",(0,o.yg)("inlineCode",{parentName:"p"},"this.state.comments")," value."))}y.isMDXComponent=!0}}]);